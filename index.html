<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-c-primer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/13/c-primer/" class="article-date">
  <time datetime="2020-08-13T10:57:48.000Z" itemprop="datePublished">2020-08-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/13/c-primer/">c++primer</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><ol>
<li>超时重传、滑动窗口、流量控制、拥塞机制。参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaolincoding/p/12732052.html">tcp图解</a><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3></li>
<li><code>os thread</code>和<code>user thread</code>的区别，参考自<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/15983872/difference-between-user-level-and-kernel-supported-threads">os/user thread</a></li>
<li>使用<code>pthread_setschedparam</code>设置c++线程的优先级，参考自<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18884510/portable-way-of-setting-stdthread-priority-in-c11">c++ thread priority</a></li>
</ol>
<h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><ol>
<li>使用nginx做热更新<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59193526">ngix热更新</a></li>
<li>使用lua脚本热更新<a target="_blank" rel="noopener" href="https://huailiang.github.io/blog/2018/luafix/">lua热更新</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/162366167">linux so热更新</a></li>
</ol>
<h3 id="paxos算法"><a href="#paxos算法" class="headerlink" title="paxos算法"></a>paxos算法</h3><ol>
<li>参考<a target="_blank" rel="noopener" href="https://juejin.im/entry/586db517ac502e12d639733b">paxos</a></li>
<li>参考<a target="_blank" rel="noopener" href="https://ocavue.com/paxos.html">图解</a></li>
<li>选择主的proposer解决paxos算法的活性问题，可以看成是一种<strong>活锁</strong>。</li>
</ol>
<h3 id="死锁和活锁"><a href="#死锁和活锁" class="headerlink" title="死锁和活锁"></a>死锁和活锁</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20566246">活锁</a></li>
<li>死锁的四个条件<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25677118">四个条件</a></li>
</ol>
<ul>
<li>互斥条件、请求和保持条件、不剥夺条件、循环等待条件。</li>
</ul>
<h3 id="读muduo前两章想到的"><a href="#读muduo前两章想到的" class="headerlink" title="读muduo前两章想到的"></a>读muduo前两章想到的</h3><ol>
<li>shared_ptr尽量采用<code>栈上对象+ pass by const reference</code>解决性能和线程安全的问题。</li>
<li><code>enable_shared_from_this</code>可以在类的成员函数实现内部，利用<code>shared_from_this()</code>转换成为<code>shard_ptr</code>类型，这样可以保证：this因为被别的owner持有，生命周期加长。</li>
<li><code>double check singleton</code>的线程安全性问题，参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/bdss58/article/details/44813597">c++线程安全的单例</a>和<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2576022/efficient-thread-safe-singleton-in-c">atomic解决方案</a></li>
</ol>
<h3 id="关于zab协议"><a href="#关于zab协议" class="headerlink" title="关于zab协议"></a>关于zab协议</h3><ol>
<li>参考<a target="_blank" rel="noopener" href="https://juejin.im/post/5b924b0de51d450e9a2de615">zab简单介绍</a>和《从paxos到zookeeper》</li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c01532ef265da61362232ed">zookeeper分布式锁</a></li>
<li><a target="_blank" rel="noopener" href="https://dbaplus.cn/news-141-2053-1.html">zookeeper的顺序一致性原理</a></li>
<li>zookeeper如果长链接太多怎么办，需要理解zookeeper的leader/follower/observer的角色，以及实际搭建的原理。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunddenly/p/4138580.html">系统学习zk系列</a></li>
</ol>
<h3 id="c-迭代器失效规则"><a href="#c-迭代器失效规则" class="headerlink" title="c++迭代器失效规则"></a>c++迭代器失效规则</h3><ol>
<li>参考自<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6438086/iterator-invalidation-rules">iterator invalidation</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6908.html">deque是通过一段段连续数组实现的</a></li>
</ol>
<ul>
<li>deque和vector相比的区别：deque支持头部插入；它们都支持随机访问；</li>
<li>list和vector相比的区别：双向链表为底层实现，支持任意位置常数时间快速插入删除（前提是找到了iterator）</li>
</ul>
<ol start="3">
<li>可以自己定义一个hashmap，<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangyun75/article/details/80866540">hashmap简单实现</a></li>
</ol>
<h3 id="redis-跳表"><a href="#redis-跳表" class="headerlink" title="redis 跳表"></a>redis 跳表</h3><ol>
<li>参考自<a target="_blank" rel="noopener" href="https://juejin.im/post/57fa935b0e3dd90057c50fbc">redis跳表</a></li>
</ol>
<h3 id="redis-rehash过程"><a href="#redis-rehash过程" class="headerlink" title="redis rehash过程"></a>redis rehash过程</h3><ol>
<li>参考自《redis设计与实践》</li>
</ol>
<h3 id="redis缓存穿透、缓存雪崩、缓存击穿"><a href="#redis缓存穿透、缓存雪崩、缓存击穿" class="headerlink" title="redis缓存穿透、缓存雪崩、缓存击穿"></a>redis缓存穿透、缓存雪崩、缓存击穿</h3><ol>
<li>缓存穿透，就是用一个<code>不存在key</code>越过缓存，直到db（虽然db也没有)；解决方案：bloom过滤</li>
<li>缓存雪崩，所有缓存<code>同时</code>失效；解决方案：设置随机值</li>
<li>缓存击穿，热点key在同一时刻被大量访问；解决方案：分布式锁。</li>
<li>参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/zeb_perfect/article/details/54135506">缓存穿透/雪崩/击穿</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/AAA821/article/details/82930679">redis性能瓶颈</a></li>
</ol>
<h3 id="dns和arp之旅"><a href="#dns和arp之旅" class="headerlink" title="dns和arp之旅"></a>dns和arp之旅</h3><ol>
<li>参考自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/iSZp41SRmh5b2bXIvzemIw">dns和arp</a></li>
</ol>
<h3 id="加密算法和https"><a href="#加密算法和https" class="headerlink" title="加密算法和https"></a>加密算法和https</h3><ol>
<li>参考自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">http和https</a></li>
<li>rsa算法和非对称加密：公钥加密后，只能用私钥解密；私钥加密后，只能用公钥解密。<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字证书</a></li>
</ol>
<h3 id="k8s的list-watch机制"><a href="#k8s的list-watch机制" class="headerlink" title="k8s的list-watch机制"></a>k8s的list-watch机制</h3><ol>
<li>list相当于全量拉取，watch使用的是<code>Transfet-Encoding:chunked</code>分块协议，参看自<a target="_blank" rel="noopener" href="http://wsfdl.com/kubernetes/2019/01/10/list_watch_in_k8s.html">k8s watch机制</a></li>
</ol>
<h3 id="etcd使用raft一致性算法"><a href="#etcd使用raft一致性算法" class="headerlink" title="etcd使用raft一致性算法"></a>etcd使用raft一致性算法</h3><ol>
<li>etcd参考自<a target="_blank" rel="noopener" href="https://draveness.me/etcd-introduction/">etcd原理</a></li>
</ol>
<h3 id="redis-sentinel-监控"><a href="#redis-sentinel-监控" class="headerlink" title="redis sentinel 监控"></a>redis sentinel 监控</h3><ol>
<li>参考自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/42ee966f96e5">sentinel监控</a></li>
</ol>
<h3 id="redis-三种集群"><a href="#redis-三种集群" class="headerlink" title="redis 三种集群"></a>redis 三种集群</h3><ol>
<li>参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/145186839">redis-sentinel和redis cluster</a></li>
</ol>
<h3 id="mysql相关"><a href="#mysql相关" class="headerlink" title="mysql相关"></a>mysql相关</h3><ol>
<li>可以好好阅读《mysql技术内幕》，简单的索引知识可以参考<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RemJcqPIvLArmfWIhoaZ1g">mysql非主键索引</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c2c8dace51d455d382ee046">最左前缀匹配</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/114993399?utm_source=wechat_session&utm_medium=social&utm_oi=43889008312320">mysql常见面试</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c0901d5cc9d2">mysql倒排索引实现全文匹配</a></li>
</ol>
<ul>
<li>常见的索引是文档id–》文档内容；倒排索引其实是文档内容–》文档id；但是叫<code>倒排</code>不合适，英文是<code>inverted index</code>转置更合适。</li>
</ul>
<ol start="5">
<li>mysiam的索引文件是个b+树，它的叶子结点的值：指向了<code>数据页的地址</code>；因此它的数据页和索引页是分开的。</li>
<li>mysql的热备份，就是<code>主从binlog的拷贝</code>。</li>
<li>mysql的主从有：一主一丛、一主多从、双主等等。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50597960">mysql主从分类</a></li>
<li><code>覆盖索引</code>就是指的不用回表。</li>
<li><code>乐观锁</code>：先从db读取version，如果要更新的话，必须<code>update db set version = version + 1 where 真实业务 AND version=上一次读的</code>才更新。参考<a target="_blank" rel="noopener" href="https://juejin.im/post/5b4977ae5188251b146b2fc8">乐观锁和悲观锁</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19719997/answer/81930332">myisam的索引页存放的是指向数据页的指针，innodb的索引页存放的是主键值</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/116866170">相对全面的mysql面试题</a> ，以及<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63377684">相对详细的介绍</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5cef2c43e51d45572c05ffe3">详细了解B+树在磁盘中的结构</a><h3 id="redis事务的原理"><a href="#redis事务的原理" class="headerlink" title="redis事务的原理"></a>redis事务的原理</h3></li>
<li>事务是把指令全服放入队列，而不是马上执行，当发送<code>EXEC</code>后一次性执行，来实现事务的<code>一致性</code>的。</li>
<li><code>watch</code>机制是把，watch相同key的所有客户端放在一个链表中；当key被改变，将该链表的所有client的<code>REDIS_DIRTY_CAS</code>选项打开，那这些client在执行<code>EXEC</code>的时候，它们的事务就会失败。<a target="_blank" rel="noopener" href="https://redisbook.readthedocs.io/en/latest/feature/transaction.html">watch redis原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fangjian1204/article/details/50585080">为什么有了事务还要lua脚本</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5cc165816fb9a03202221dd5">redis分布式锁</a></li>
<li>分布式锁依然出问题：client1加锁后，锁超时client2获取锁；此时client1还在执行————引入chubby的实现。还有一种是redission，实际就是业务有个<code>看门狗</code>不断续期<a target="_blank" rel="noopener" href="https://blog.csdn.net/wutengfei_java/article/details/100699538">分布式锁超时</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/29327544/pipelining-vs-transaction-in-redis">redis pipeline和transaction区别</a>；二者都能保证批量指令按照顺序执行；但是pipeline中的指令会被其它redis client的请求指令插入；但是transaction可以保证批量指令为一个atomic的操作。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Muscleape/article/details/105670481">redis rdb采用了fork子进程的cow技术</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5dccf260f265da0bf66b626d">redis sdown和odown</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bb857f883ccb">redis集群的moved和ask重定向</a></li>
</ol>
<h3 id="redis-cluster-槽位"><a href="#redis-cluster-槽位" class="headerlink" title="redis cluster 槽位"></a>redis cluster 槽位</h3><ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/80335611">16384个slot</a></li>
</ol>
<h3 id="关于bitmap算法和kmp算法"><a href="#关于bitmap算法和kmp算法" class="headerlink" title="关于bitmap算法和kmp算法"></a>关于bitmap算法和kmp算法</h3><ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/r2WtHW7UcinIjelILSnWwg">bitmap求一个数是否在40亿中出现</a></li>
<li>kmp算法就是字符串匹配,<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21923021">kmp</a></li>
</ol>
<h3 id="c-智能指针简单实现"><a href="#c-智能指针简单实现" class="headerlink" title="c++智能指针简单实现"></a>c++智能指针简单实现</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33762043/article/details/80072391">智能指针简单实现</a></li>
</ol>
<h3 id="shmget和semget"><a href="#shmget和semget" class="headerlink" title="shmget和semget"></a>shmget和semget</h3><ol>
<li>shmget是<code>具名</code>的共享内存，semop可以实现信号量的<code>PV</code>操作。参考自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/forstudy/archive/2012/03/26/2413724.html">shmget和semop</a></li>
</ol>
<h3 id="fifo-和pipe"><a href="#fifo-和pipe" class="headerlink" title="fifo 和pipe"></a>fifo 和pipe</h3><ol>
<li>参考自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/littlehann/p/6906164.html">fifo和pipe</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d4bb6d4f8e4c">unixsocket简单理解</a></li>
</ol>
<h3 id="可靠udp"><a href="#可靠udp" class="headerlink" title="可靠udp"></a>可靠udp</h3><ol>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5e6b6f696fb9a07cc61cfd0c">介绍可靠udp</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6c73a4585eba">udp使用seq-ack/缓冲区用来重传</a></li>
</ol>
<h3 id="条件变量的虚假唤醒"><a href="#条件变量的虚假唤醒" class="headerlink" title="条件变量的虚假唤醒"></a>条件变量的虚假唤醒</h3><ol>
<li>参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/Leeds1993/article/details/52738845">condition_variable的虚假唤醒</a></li>
</ol>
<h3 id="nat简介"><a href="#nat简介" class="headerlink" title="nat简介"></a>nat简介</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/CrystalShaw/article/details/80677966">nat简单介绍</a></li>
</ol>
<h3 id="redis和db双写一致性、redis惰性删除、redis-cluster和redis-sentinel对比、redis事务"><a href="#redis和db双写一致性、redis惰性删除、redis-cluster和redis-sentinel对比、redis事务" class="headerlink" title="redis和db双写一致性、redis惰性删除、redis-cluster和redis-sentinel对比、redis事务"></a>redis和db双写一致性、redis惰性删除、redis-cluster和redis-sentinel对比、redis事务</h3><ol>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5db6e4f7e51d4529ed291bb0">redis-事务</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/136796077">redis惰性删除内存</a></li>
<li>rdb模式和aof模式持久化，参考《redis设计与实现》</li>
<li>最经典的redis和db双写一致性：先读内存，再读db；先写db，再<code>删除内存</code>；删除而非更新的原因——懒加载内存。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50392209">redis的惰性删除和内存淘汰策略之间的关系</a></li>
</ol>
<h3 id="mongo的锁"><a href="#mongo的锁" class="headerlink" title="mongo的锁"></a>mongo的锁</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d838a5905303">mongo意向锁</a></li>
</ol>
<h3 id="操作系统简介"><a href="#操作系统简介" class="headerlink" title="操作系统简介"></a>操作系统简介</h3><ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247485559&idx=1&sn=dfc9973ebf045284c771efa74cfc4ee7">操作系统简介</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247485619&idx=1&sn=819fffc4380b4e976f541def5ed805f3">进程和线程简介</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247485927&idx=1&sn=a05bd80ed7147ed9b66be3807747c450">文件系统ntfs/fat和inode</a></li>
<li>磁盘的顺序io和随机io：本次io的初始扇区地址和上次io的结束扇区地址相同，不需要磁头换道，因而非常快！</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22482058">fat和ext2的比较</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/rSO5RJzY620zWo-VPWQ0aQ">物理内存的buddy算法和slab分配器</a></li>
<li><code>mount 磁盘分区 挂载目录</code>，目录是逻辑上的区分，分区是物理上的区分。<a target="_blank" rel="noopener" href="https://kknews.cc/code/alzmjgx.html">fdisk管理分区</a></li>
</ol>
<ul>
<li>inode节点、data block等都属于物理上的磁盘分区。<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangpower1993/article/details/52213030">磁盘分区和挂载目录</a></li>
</ul>
<ol start="8">
<li>linux的虚拟文件系统。</li>
</ol>
<ul>
<li>每次通过mount安装一个文件系统，都唯一对应一个<code>超级块super_block</code>和<code>挂载点vfsmount</code>。其中超级块会记录<code>实际物理文件的inode信息</code>。super_block和vfsmount就是mount的两个参数，可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/jasonchen_gbd/article/details/51511261">vfs介绍</a></li>
<li>多个进程内存中的<code>不同的struct file文件对象</code>，可以同时打开和操作<code>同一个物理文件</code>，可以参考<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-vfs/">linux虚拟文件系统</a></li>
<li>每个进程都有自己的<code>file descriptor table文件描述符表</code>，同时内核维护<code>唯一的open file table</code>，因此不同进程的相同fd可能指向<code>相同的物理文件</code>。而linux也提供<code>dup/dup2</code>等函数复制fd，参考<a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/28384/how-can-same-fd-in-different-processes-point-to-the-same-file">same fd</a></li>
<li>fork子进程拷贝了自己的<code>文件描述符表</code>，但是父子进程的<code>struct file文件对象</code>只有一份。参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/u014379540/article/details/53456070">文件描述符表</a></li>
<li><a target="_blank" rel="noopener" href="https://books.google.com.hk/books?id=QXj6AQAAQBAJ&pg=PA133&lpg=PA133&dq=file+blocks+not+adjacent&source=bl&ots=4eprmT6Uuz&sig=ACfU3U1qFOyGzpEVE4aYtaWrEO_PjwtvRw&hl=en&sa=X&redir_esc=y#v=onepage&q&f=false">inode和block描述</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ed992f7f265da76bb013e72">磁盘io描述</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1058303">kafka的顺序写</a><h3 id="c-this和vptr指针"><a href="#c-this和vptr指针" class="headerlink" title="c++ this和vptr指针"></a>c++ this和vptr指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="literal">nullptr</span>;</span><br><span class="line">    a-&gt;foo();<span class="comment">//函数在code段，有个隐藏的入参this指针，此时this为nullptr，但是函数体没有用this，正确</span></span><br><span class="line">    a-&gt;bar();<span class="comment">//错误，因为要通过a的vptr去找vtbl，但vptr根本找不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strncpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">size_t</span> n)</span></span>&#123;<span class="comment">//自定义strncpy</span></span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i =<span class="number">0</span>; i&lt;n&amp;&amp; src[i]!= <span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        dest[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        dest[i++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程和线程的真实区别"><a href="#进程和线程的真实区别" class="headerlink" title="进程和线程的真实区别"></a>进程和线程的真实区别</h3></li>
</ul>
<ol>
<li>参考自<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/25532384/answer/81152571">上下文</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/anker/p/3271773.html">孤儿进程和僵尸进程</a></li>
</ol>
<h3 id="ip和traceroute原理"><a href="#ip和traceroute原理" class="headerlink" title="ip和traceroute原理"></a>ip和traceroute原理</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/75a5822d0eec">traceroute原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/n/74f38cd527484ae78f3404f24e7d3e5b">icmp的数据包格式</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/f2006116/article/details/51159895">ping的原理</a></li>
</ol>
<h3 id="算法补缺"><a href="#算法补缺" class="headerlink" title="算法补缺"></a>算法补缺</h3><ol>
<li>二叉树的后序遍历，非递归。使用栈来做，前序遍历(根-》左-》右)，变成（根-》右-》左），然后反转一下（左-》右-》根）就是了。</li>
<li>threeSum，可以先把数据排序，然后针对每一个元素，进行首尾双指针即可。</li>
<li>twosum就使用简单的unordered_map。</li>
<li>反转字符串也可以使用双指针。</li>
<li>trie树的时间复杂度是o(len(key))和输入的长度有关，和树高度无关；而bst的时间复杂度就和树高有关，可以参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/">trie前缀树</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/luanpeng825485697/article/details/79974835">topk问题</a>，也可以参考<a target="_blank" rel="noopener" href="https://juejin.im/entry/5c565fb7f265da2d84105958">堆解决topk问题</a></li>
</ol>
<h3 id="缺页中断后的页面置换算法"><a href="#缺页中断后的页面置换算法" class="headerlink" title="缺页中断后的页面置换算法"></a>缺页中断后的页面置换算法</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Alatebloomer/article/details/79976068">物理内存的页面置换算法</a></li>
</ol>
<h3 id="c-的vector为什么是2倍增加"><a href="#c-的vector为什么是2倍增加" class="headerlink" title="c++的vector为什么是2倍增加"></a>c++的vector为什么是2倍增加</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/bryant_xw/article/details/89524910">保证push_back均摊O(1)</a></li>
</ol>
<h3 id="unique-ptr和shared-ptr删除器"><a href="#unique-ptr和shared-ptr删除器" class="headerlink" title="unique_ptr和shared_ptr删除器"></a>unique_ptr和shared_ptr删除器</h3><ol>
<li>unique_ptr通过编译时绑定删除器；shared_ptr通过运行时绑定删除器。</li>
</ol>
<h3 id="docker隔离"><a href="#docker隔离" class="headerlink" title="docker隔离"></a>docker隔离</h3><ol>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17010.html">linux namespace隔离环境</a></li>
<li><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17049.html">linux cgroup隔离资源</a></li>
<li>docker通过mount namespace来实现文件系统的隔离，docker内部的挂载点<code>/var</code>在物理机上可能实际是<code>/var/lib/&lt;container&gt;/rootfs/var</code>。</li>
<li>docker和vm的最大区别是：vm多了一个<code>guest OS</code>操作系统；而docker因为隔离了文件系统/资源等，可以直接使用主机的OS操作系统，而无需自己的<code>guest OS</code>，因此可以节省大量的磁盘空间。</li>
</ol>
<h3 id="union判断字节序"><a href="#union判断字节序" class="headerlink" title="union判断字节序"></a>union判断字节序</h3><ol>
<li>大端序：低地址存放数据的高位；高地址存放数据的低位；小端序相反。</li>
</ol>
<ul>
<li>比如0x1234从地址0x4000存放。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x4000 0x12 //大端序</span><br><span class="line">0x4001 0x34</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_big_endian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        uint_32 i;</span><br><span class="line">        <span class="keyword">char</span>[<span class="number">4</span>] c;</span><br><span class="line">    &#125;u = &#123;<span class="number">0x01020304</span>&#125;; <span class="comment">//联合体成员的存储是重叠的，此时i是活跃的</span></span><br><span class="line">    <span class="keyword">return</span> u.c[<span class="number">0</span>] == <span class="number">1</span>; <span class="comment">//union是从低地址存放的，如果c的第0个元素（低地址）存放的是0x01则为大端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="poll-select-epoll区别"><a href="#poll-select-epoll区别" class="headerlink" title="poll/select/epoll区别"></a>poll/select/epoll区别</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/anker/p/3265058.html">epoll/poll/select区别</a></li>
</ol>
<h3 id="c-反射机制简单实现"><a href="#c-反射机制简单实现" class="headerlink" title="c++反射机制简单实现"></a>c++反射机制简单实现</h3><ol>
<li>使用map&lt;string, functor&gt;保存string对应的函数指针，工厂类根据传入的string，调用对应的函数指针构造即可。参考自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xudong-bupt/p/6643721.html">c++反射</a></li>
</ol>
<h3 id="锁在操作系统层面的实现"><a href="#锁在操作系统层面的实现" class="headerlink" title="锁在操作系统层面的实现"></a>锁在操作系统层面的实现</h3><ol>
<li>锁本质就是一个内存空间。如果被赋值了就是加了锁。硬件的CPU提供CMPXCHG指令，实现原子粒度的CAS，能保证同一时刻只有一个线程能够抢到锁。</li>
<li>其它线程要不然spinlock一直抢；要么申请挂起让出cpu，就是mutex。参考自<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/332113890">锁底层实现</a></li>
</ol>
<ul>
<li>忙等待就是spinlock</li>
</ul>
<h3 id="中断原理"><a href="#中断原理" class="headerlink" title="中断原理"></a>中断原理</h3><ol>
<li>中断就是设备在就绪之后，发送中断信号给CPU，这是CPU根据中断优先级去暂停当前任务，处理设备的中断任务。否则CPU需要一直等在设备上<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Jack-Blog/p/12038716.html">中断</a></li>
</ol>
<h3 id="c-读写锁"><a href="#c-读写锁" class="headerlink" title="c++读写锁"></a>c++读写锁</h3><ol>
<li>使用mutex，再加上condition_variable，和两个引用计数；可以实现自己的读写锁，C++17有提供shared_mutex，参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/zxc024000/article/details/88814461">自定义读写锁</a></li>
</ol>
<h3 id="dns的a-cname-ns"><a href="#dns的a-cname-ns" class="headerlink" title="dns的a/cname/ns"></a>dns的a/cname/ns</h3><ol>
<li>A返回域名指向的IP地址，CNAME返回另外一个域名，NS保存下一级域名信息的服务器域名，可以参考<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/06/dns.html">dns释义</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SRV%E8%AE%B0%E5%BD%95">dns的srv记录</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/208f268e18f4">/etc/resolv.conf配置</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/80141656">kubedns的原理介绍</a>。简单来说kubedns监控service和endpoint的变化，并将最新的变化维护进内存来服务<code>svc-a.namespace</code>等类似的请求。</li>
<li>kubedns和kubeproxy、api-server等一样都是在<code>kube-system</code>命名空间下的pod。<code>kubedns</code>所在的ip和，任意节点的用户pod中的<code>/etc/resolv.conf:nameserver</code>是一样的，这样用户pod就可以调用到kubedns。</li>
</ol>
<ul>
<li>kubedns中的<code>模块kubedns</code>监控service和endpoint的变化，并将最新的变化维护进内存。<code>skydns模块</code>真正负责dns解析。<a target="_blank" rel="noopener" href="https://www.kubernetes.org.cn/542.html">k8s服务发现</a></li>
<li>用户pod通过kube-dns解析到<code>svc-a.namespace</code>的<code>service ip</code>之后（即服务发现）；再通过<code>kube-proxy</code>的<code>iptables</code>实现<code>service ip</code>到真实后端的<code>pod ip</code>的负载均衡。参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/devilwind/p/8881148.html">k8s负载均衡和服务发现</a>，简单来说就是通过<code>iptables</code>的 <code>probability</code> 特性来做到的。</li>
<li>k8s的存活探针除了使用<code>http</code>探测之外，还可以使用<code>command</code>命令探测，返回0则认为正常。</li>
</ul>
<h3 id="oauth和jwt"><a href="#oauth和jwt" class="headerlink" title="oauth和jwt"></a>oauth和jwt</h3><ol>
<li>jwt主要依赖服务端有一个<code>密钥</code>，<code>HS256</code>对称加密算法利用密钥，加密payload，防止<code>内容伪造</code>。<a target="_blank" rel="noopener" href="http://blog.leapoahead.com/2015/09/06/understanding-jwt/">jwt介绍</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/">jwt和常见session区别</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903842773991431">session和cookie</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html">OAuth 的核心就是向第三方应用颁发令牌</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">通过client_id和client_secret拿到令牌</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/04/github-oauth.html">oauth实际例子:令牌最终在authorization中</a></li>
</ol>
<h3 id="bitmap算法"><a href="#bitmap算法" class="headerlink" title="bitmap算法"></a>bitmap算法</h3><ol>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c4fd2af51882525da267385">bitmap介绍</a></li>
</ol>
<h3 id="双缓冲技术"><a href="#双缓冲技术" class="headerlink" title="双缓冲技术"></a>双缓冲技术</h3><ol>
<li>pass</li>
</ol>
<h3 id="敖丙的复习之路"><a href="#敖丙的复习之路" class="headerlink" title="敖丙的复习之路"></a>敖丙的复习之路</h3><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/AobingJava/JavaFamily?utm_source=wechat_session&utm_medium=social&utm_oi=43889008312320">整体复习</a>，这个相当于从各方面整体复习一遍，值得面试时好好看看。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/13/c-primer/" data-id="ckdsoysil00019y0c9j8y4bmu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-thinking-in-java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/13/thinking-in-java/" class="article-date">
  <time datetime="2020-08-13T10:44:40.000Z" itemprop="datePublished">2020-08-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/13/thinking-in-java/">thinking-in-java</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Thinking-in-java"><a href="#Thinking-in-java" class="headerlink" title="Thinking in java"></a>Thinking in java</h2><h3 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h3><ol>
<li>access control: <code>package access</code>默认是<code>private</code></li>
<li>使用基类的指针/引用指向派生类的对象，在java中叫做<code>upcasting</code>，up原因是在uml中base class都是在最上面的。</li>
<li>rooted hierarchy: 对于java而言<code>Object</code>是所有对象的基类，这对于<code>garbage collector</code>很有用。</li>
<li>applet: An applet is a mini-program that will run only under a Web browser. applet是java丰富了客户端编程技术，一般browser是需要写js文件的。<h3 id="everything-is-a-object"><a href="#everything-is-a-object" class="headerlink" title="everything is a object"></a>everything is a object</h3></li>
<li><code>String s; s = new String(&quot;asdf&quot;);</code>其中<code>s</code>是一个<code>reference</code>，就是c++中的指针，放在<code>stack</code>上；真实对象放在<code>heap</code>堆里。</li>
<li><code>primitive type</code>：基本类型比如<code>boolean/char/short/int/long/double</code>等可以直接在<code>stack</code>上创建(<code>char c = &#39;x&#39;</code>)这样效率更高；而且和c++不同基本类型占用的字节数<code>固定</code>和机器无关。</li>
</ol>
<ul>
<li><code>Character ch = new Character(&#39;x&#39;);</code>基本类型也具备对应的<code>wrapper type</code>。</li>
</ul>
<ol start="3">
<li><code>Arrays in java</code>：和c++不同的是，java保证<code>array</code>默认<code>initialize为null</code></li>
</ol>
<ul>
<li>create an array of object，等价与creat <code>an array of references and each reference is automatically initialized to null</code>。</li>
</ul>
<ol start="4">
<li><code>default values for primitive class memebers</code>：针对类中的基础类型，和c++不同的是，java保证初始化。</li>
</ol>
<ul>
<li>如果是基础类型则保证为0，如果是类类型则保证为null。</li>
</ul>
<ol start="5">
<li><code>name visibility</code>：和c++需要使用<code>namespace</code>来解决重定义问题不一样，java使用<code>net.mindview.Class</code>的<code>domain name</code>来解决名字冲突问题。</li>
</ol>
<ul>
<li><code>import java.util.ArrayList;</code>java使用<code>import</code>关键词来指定类的路径；注意<code>java.lang</code>包是隐式被import到所有的java文件中的，所以<code>String</code>等类就不用显式import。</li>
</ul>
<ol start="6">
<li><code>compiling and running</code>：编译通过<code>javac xx.java</code>产生java的字节码<code>xx.class</code>；运行通过<code>java xx</code>即可。了解下jdk和jre的区别。<h3 id="operators"><a href="#operators" class="headerlink" title="operators"></a>operators</h3></li>
<li><code>==</code>和<code>equals()</code>：<code>object</code>类中<code>equals</code>的默认实现就是比较<code>this</code>指针，派生的<code>Integer/String</code>类的<code>equals</code>则比较内容；<code>==</code>默认肯定是比较<code>this</code>指针，因此如果想判断<code>String</code>的内容是否相等用equals。</li>
<li><code>&gt;&gt;</code>和<code>&gt;&gt;&gt;</code>：针对<code>&gt;&gt;</code>和c++一样，如果是positive，高位就填充0，如果是negative，高位就填充1；和<code>&gt;&gt;&gt;</code>则不管统一填充0。</li>
<li><code>&quot;&quot;+a</code>是一个比较常见的int转string方式（类似于Integer.toString()).</li>
<li>关于<code>label</code>标签只有一种用法如下，<code>continue label1</code>将会跳到外层循环，并且继续从外层循环开始执行；而<code>break label1</code>也会跳到外层循环，但直接终止不会<code>reenter</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> label1:</span><br><span class="line">    outer-iteration &#123;</span><br><span class="line">      inner-iteration &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// (1)</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// (2)</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">continue</span> label1; <span class="comment">// (3)</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">break</span> label1; <span class="comment">// (4)</span></span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="initialization-amp-cleanup"><a href="#initialization-amp-cleanup" class="headerlink" title="initialization &amp; cleanup"></a>initialization &amp; cleanup</h3></li>
<li><code>calling constructors from constructors</code>：可以使用<code>this</code>在constructor中调用其它constructor，不过必须是<code>第一行</code>；类似于<code>Base(int a, int b)&#123;this(a);...&#125;</code>。</li>
<li><code>finalize</code>：是类的一个方法，它的目的通常是做一些<code>gc</code>无法处理的<code>cleanup</code>工作。</li>
</ol>
<ul>
<li>gc只能释放<code>new</code>占用的内存；它会首先调用类的<code>finalize()</code>方法，然后gc；</li>
<li>比如说在java中调用了<code>c++</code>的<code>malloc</code>，那么就需要在<code>finalize</code>中调用<code>free</code>释放，这是finalize存在的部分原因。</li>
<li>finalize的另外一个使用场景：在其中<code>close file</code>关闭已经打开的文件句柄，防止句柄泄露。</li>
<li>jvm只会在<code>必要</code>的时候调用gc以释放内存；finalize方法<code>不能主动调用</code>；因此如果一定要个类似于c++的destructor，就显示在java中定义这个方法，再显示调用吧。</li>
</ul>
<ol start="3">
<li><code>order of initilization</code>：和c++不同，java可以在定义class时，在其中可以直接给<code>member variable</code>写初始化语句，即使初始化语句写在<code>constructor</code>后面，也是先执行自身的<code>init</code>然后调用<code>constructor</code>。</li>
</ol>
<ul>
<li>当某个类第一次被调用，<code>xx.class</code>需要被load，就在此时该类的<code>static</code>成员被有且仅初始化一次；因此<code>static</code>成员变量的初始化时机最早。</li>
<li>java允许static成员直接在定义时初始化；同时java还支持<code>static initialization和instance initialization</code>这种语法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">10</span>; <span class="comment">// static initialization</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">20</span>; <span class="comment">//instance initialization</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>array init: <code>int []a = new int[2];</code>默认初始化元素为0；等价于<code>Integer []a = new Integer[2]; a[x] = 0;</code>，因为<code>a[x]</code>如果不去初始化，则其中的引用默认为null；也可以直接初始化<code>Integer []a = new Integer[2]&#123;0, 0&#125;</code>。</li>
<li><code>toString</code>方法：基类Object默认是打印<code>ClsName@Addr</code>。</li>
<li><code>variable argument list</code>：语法为<code>void f(Object... args)</code>类似于c++的模版参数包，可以传递变参。</li>
<li>enum：enum的语法类似于c++的<code>enum class</code>，<code>enum A&#123;Red, Green, Blue&#125; A x = A.Red;</code>，它还有<code>ordinal()</code>方法用来获取从0开始的排号。<h3 id="access-control"><a href="#access-control" class="headerlink" title="access control"></a>access control</h3></li>
<li>package the library unit: 对于java来说，每一个源文件叫做<code>compilation unit</code>，在这个源文件中有且仅有一个<code>同名的public class</code>；如果定义其它class，则不能为<code>public</code>，该class会被package隐藏，<code>不会暴露</code>。</li>
<li>code organization: 源文件.java–&gt; 编译成.class–&gt; packaged and compressed into <code>jar file</code>—&gt; jvm负责装载、解释；</li>
</ol>
<ul>
<li>如果要开发第三方库，则开发者需要使用<code>package</code>，使用者使用<code>import</code>；并且使用者需要在<code>PATH</code>中添加路径；针对<code>jar</code>包需要在PATH中写入<code>全路径</code>(如C:\xx\graph.jar)</li>
<li>注意<code>import</code>进来的两个包如果有相同的class名，造成了<code>collision</code>，则在使用时<code>使用全名</code>即可。</li>
<li>如果没有写<code>package...</code>则会把<code>当前文件</code>当作<code>default package for current directory</code>。</li>
<li><code>import static java.lang.System.*;</code> import static可以导入所有的static方法和对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: access/mypackage/MyClass.java</span></span><br><span class="line"><span class="keyword">package</span> access.mypackage;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//: access/ImportedMyClass.java</span></span><br><span class="line"><span class="keyword">import</span> access.mypackage.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportedMyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyClass m = <span class="keyword">new</span> MyClass();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>package access：对于java而言如果不加任何的<code>access specifier</code>则使用的就是<code>package access</code>权限，即针对<code>相同package内</code>的其它class它是<code>public</code>可见的；针对<code>不在同一个package</code>的其它class它是<code>private</code>不可见的。</li>
</ol>
<ul>
<li>对于class，只能有<code>public</code>或者<code>package access</code>。（除了内部类，内部类可以是private或者protected的)</li>
</ul>
<ol start="4">
<li>protected ：如果某个方法使用<code>protected</code>关键字，那么针对<code>不在同一个package</code>的其它<code>派生类</code>依然是可见的。</li>
</ol>
<ul>
<li>protected如其最基本的含义，对于<code>使用者</code>是不可见的，但是对于<code>派生类的定义</code>是可见的。</li>
<li>java的protected另外一层含义是<code>package access</code>即针对<strong>同包的其它文件可见</strong>！从原文解释为——this is <code>private as far as the class user</code>, but available to anyone who inherits from this class or <code>anyone else in the same package</code>。</li>
<li>记住java的<code>package</code>的概念是：同包内的所有文件来自于<code>同一个designer</code>；这有助于理解权限。</li>
</ul>
<h3 id="reusing-classes"><a href="#reusing-classes" class="headerlink" title="reusing classes"></a>reusing classes</h3><ol>
<li>inheritance syntax: 基本语法为<code>class Derived extends Base</code>通过关键词<code>extends</code>实现，和c++需要使用<code>virtual</code>关键词开启多态不同，java默认就开启多态。（除了static和final方法之外，所有方法默认多态）。</li>
</ol>
<ul>
<li><code>public static void main(String[] args)</code>是java的程序入口。</li>
<li>派生类调用基类方法<code>super.fun()</code>使用<code>super</code>关键字。</li>
</ul>
<ol start="2">
<li>initialize the base class: 在派生类的构造函数写上<code>super(xx)</code>即可先执行基类的构造函数；如果是<code>default constructor</code>（即无参数），java语言会默认调用基类默认构造函数。</li>
<li>finally：<code>try &#123;&#125;finally&#123;&#125;</code>子句，<code>finally always executed, no matter how the try block happen</code>，针对<code>非内存清理</code>的cleanup(gc只管内存清理)，可以在finally中做；比如某些业务逻辑。</li>
</ol>
<ul>
<li>类似于c++的destructor，不过destructor不用显示调用；相同点在于<code>逆序</code>调用即从derived开始最后到base。</li>
</ul>
<ol start="4">
<li>final data：<code>final</code>关键字作用在<code>primitive</code>基本类型上就是c++的constant的意思，表示是常量；作用在<code>object reference</code>上就相当于c++的<code>const 指针</code>——即不能在指向其它object，但是object自身可以modified。</li>
</ol>
<ul>
<li>一般情况下针对<code>primitive</code>会写成<code>public static final VALUE_A = 10</code>即<code>static final</code>一起用，static表示有且仅有一份内存，final表示constant；当然不是说一定要连在一起用。</li>
<li><code>final Base b = Base(1); b.x = 10;</code>针对类添加final只是说<code>reference</code>加了final，修改它的object还是可以的；但是<code>b = Base(2)</code>是错误的；</li>
<li>相同的原因<code>final int[] a=&#123;1, 2&#125;; a[0]++;</code>是正确的，final遇到数组也是加在所谓的<code>reference</code>上。</li>
<li>和c++的const不同的是，可以在类中声明final成员，然后在构造函数中再初始化final成员——这叫做<code>blank final</code></li>
</ul>
<ol start="5">
<li>final methods：第一种用法是<code>prevent inheriting class changing method meaning</code>；第二种用法相当于c++的<code>inline</code>内联函数，不过现在虚拟机一般会自动优化。</li>
</ol>
<ul>
<li>针对<code>private methods</code>默认就带有<code>final</code>属性因为它不能被继承；但是如果基类是<code>public final method</code>派生类默认是拥有的，只是不能<code>change</code>。</li>
</ul>
<ol start="6">
<li>final class：就是这个类<code>不能被继承</code>。<h3 id="polymorphism"><a href="#polymorphism" class="headerlink" title="polymorphism"></a>polymorphism</h3></li>
<li>多态：<code>Shape s = new Circle(); s.draw();</code>多态常见的用法和c++类似，使用基类的指针指向派生类的对象。一种良好的设计模式如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span></span>&#123;</span><br><span class="line">    i.play();<span class="comment">//接口可以保持不变</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>如前所述：针对<code>static/final</code>方法和同名的<code>field</code>，<code>Base b = new Derived(); b.sameF; b.staticFunc();</code>都不会触发多态，原因是在<code>编译时就决定</code>，而非运行时。</li>
<li>polymorphic method inside constructors：和c++一样，不要在构造函数中调用多态函数。</li>
<li>RTTI：就是downcast，类似于<code>Base b = new Derived(); ((Derived)b).derivedFun();</code>这种在运行时检查类型的方式就是<code>runtime type identification</code>；类似于c++的dynamic_cast。<h3 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces"></a>interfaces</h3></li>
</ul>
<ol>
<li>abstract class：和c++的<code>pure virtual function</code>类似，使用<code>abstract void f();</code>这种<code>abstract</code>关键字的无body函数，就是<code>抽象类</code>。</li>
</ol>
<ul>
<li>也可以使用<code>abstract class A&#123;&#125;</code>关键字直接修饰类得到<code>抽象类</code>。</li>
</ul>
<ol start="2">
<li>interface：是一个完全的接口，里面只能包含<code>方法声明</code>和<code>字段</code>；方法默认是<code>public</code>的，字段默认是<code>public static final</code>的。</li>
</ol>
<ul>
<li>使用<code>implements</code>关键字实现这个interface；除此之外interface和class无异（包含<code>多态</code>等特性）；接口最大的功用就是decoupling，比类更加解耦。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Compile-time constant:</span></span><br><span class="line">  <span class="keyword">int</span> VALUE = <span class="number">5</span>; <span class="comment">// static &amp; final</span></span><br><span class="line">  <span class="comment">// Cannot have method definitions:</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span></span>; <span class="comment">// Automatically public</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">implements</span> <span class="title">Instrument</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>multiple inheritance：和c++可能会出现<code>菱形继承</code>不同，java只允许<code>extends</code>一个基类，但是允许<code>implements</code>无限个interface；同时多态的特性允许派生类<code>upcast</code>成为任意一个interface或者基类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFight</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">CanSwim</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ActionCharacter</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">ActionCharacter</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">CanFight</span>, <span class="title">CanSwim</span>, <span class="title">CanFly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>entending an interface with inheritance：和类相似，interface也可以通过<code>extend</code>派生出新的接口。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DangerousMonster</span> <span class="keyword">extends</span> <span class="title">Monster</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>adapting to an interface：把接口当作<code>函数参数</code>将非常有利于适配该函数。如下所示任何实现了<code>Readable</code>接口的自定义类都可以被<code>Scanner</code>使用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Readable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(java.nio.CharBuffer cb)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Scanner</span><span class="params">(Readable source)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>factories：介绍工厂类的最常见用法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">  <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;<span class="comment">//工厂的interface用来返回要生产的Object</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factories</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory fact)</span></span>&#123;<span class="comment">//真实消费的方法传入一个工厂的interface</span></span><br><span class="line">    Service s = fact.getService();<span class="comment">//工厂类生产Object</span></span><br><span class="line">    s.fun();<span class="comment">//用生产出来的Object进行业务</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    serviceConsumer(<span class="keyword">new</span> ImplementationFactoryA());</span><br><span class="line">    serviceConsumer(Implementation1.factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImplementationServiceA</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImplementationFactoryA</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span></span>&#123;&#125; <span class="comment">//实际的实现，可以是A/B/C</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Implementation1</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//构造函数使用private</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory factory = <span class="keyword">new</span> ServiceFactory()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Implementation1();&#125;</span><br><span class="line">  &#125;;<span class="comment">//使用匿名内部类创建factory对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inner-Classes"><a href="#Inner-Classes" class="headerlink" title="Inner Classes"></a>Inner Classes</h3></li>
<li>the link to the outer class：针对<code>non-static</code>的内部类，它默认会持有<code>外部类</code>的引用，所以能够在内部类中<code>能直接访问外部类的所有成员</code>—— <code>inner classes have access rights to all the elements in the enclosing class</code>.</li>
</ol>
<ul>
<li>外部类的<code>non-static</code>方法访问内部类：<code>直接使用InnerClass名</code>即可；外部类的<code>static</code>方法访问内部类：<code>使用OuterClass.InnerClass</code>。</li>
<li>内部类访问外部类的变量：<code>直接使用外部类的field名</code>；访问外部类的this指针：<code>使用OuterClass.this</code>。</li>
<li>创建<code>内部类对象</code>：需要<code>首先创建外部类对象</code>，语法为<code>OuterClass out = new OuterClass(); OuterClass.InnerClass inner = out.new InnerClass();</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DotThis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;DotThis.f()&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> DotThis <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            out.println(a);</span><br><span class="line">            <span class="keyword">return</span> DotThis.<span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// A plain &quot;this&quot; would be Inner’s &quot;this&quot;</span></span><br><span class="line">        &#125; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Inner(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotThis dt = <span class="keyword">new</span> DotThis();</span><br><span class="line">        DotThis.Inner dti = dt.inner();</span><br><span class="line">        dti.outer().f();</span><br><span class="line">        DotThis.Inner dti2 = dt.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>inner classes and upcasting：内部类的一个通用做法是，使用<code>private 内部类 implements 接口</code>来实现具体细节，使用者<code>使用的是接口，因而完全不清楚实现细节</code>，如下所示。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parcel4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PContents();</span><br><span class="line">    &#125; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParcel</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Parcel4 p = <span class="keyword">new</span> Parcel4();</span><br><span class="line">    Contents c = p.contents(); <span class="comment">//使用者不需要知道内部实现</span></span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li>inner classes in methods and scopes：内部类除了可以定义在外部类里，也可以定义在<code>method或者某个块</code>里面；比如定义在method里，<code>inner class cannot be accessed outside of the method</code>出了函数体无法<code>直接访问</code>内部类；因此常见做法和上述类似，通过<code>upcast</code>返回<code>内部类实现的接口</code>，接口对于user而言是可见的。</li>
<li>anonymous inner class：匿名内部类既可以<code>implements 接口</code>，又可以<code>extends 基类</code>。</li>
</ol>
<ul>
<li>如果在匿名内部类的定义里面使用了外部的变量，外部变量需要<code>使用final</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;<span class="comment">//等价于上面的PContents，这里使用了接口的default constructor</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;i = x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//extends 基类的有参构造函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x)&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y1 = y;<span class="comment">//如果在匿名内部类的定义里面，使用了外部的变量需要使用final</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.value()*<span class="number">2</span>;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li>factory method revisit：重新回顾工厂类的模式，添加上<code>匿名内部类</code>可以把实现细节给隐藏，具体可以参考前述。</li>
<li>nested class：和前述的<code>inner class</code>相比，<code>nested class</code>是专门指<code>static inner class</code>；其中最大的区别是——<code>static inner class不会默认持有外部类的this指针</code>。</li>
</ol>
<ul>
<li>外部类的<code>non-static/static</code>方法访问内部类：<code>直接使用InnerClass名</code>即可；</li>
<li><code>static inner class</code>访问外部类：只能访问<code>外部类的static field</code>；</li>
</ul>
<ol start="7">
<li>why inner classes：为什么不在<code>外部类impements内部类实现的接口</code>呢？原因是——有时外部类并没有implements对应的接口，而内部类就打破了这种限制。</li>
</ol>
<ul>
<li>java规定一个类只有一个base class，而内部类可以<code>extends class</code>，某种意义就突破了这层限制。</li>
</ul>
<ol start="8">
<li>closures &amp; callbacks：<code>closures</code>的定义是一个保存<code>环境信息</code>的<code>可执行对象</code>，<code>a callable object that retains information from the scope in which it was created</code>；java的内部类持有外部类的this指针因此是<code>clousure</code>。</li>
</ol>
<ul>
<li>c++使用<code>函数指针</code>实现callback功能；而java没有指针，java采用<code>closures</code>实现回调的功能。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Specify outer-class method, otherwise you’d get an infinite recursion:</span></span><br><span class="line">            Callee2.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125; &#125;</span><br><span class="line">    <span class="function">Incrementable <span class="title">getCallbackReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line">    Caller(Incrementable cbh) &#123; callbackReference = cbh; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123; callbackReference.increment(); &#125;</span><br><span class="line">&#125;</span><br><span class="line">Callee2 ce = <span class="keyword">new</span> Callee2();</span><br><span class="line">Caller c = Caller(ce.getCallbackReference());</span><br><span class="line"><span class="comment">//合适时机调用c.go();</span></span><br></pre></td></tr></table></figure>
<h3 id="holding-your-objects"><a href="#holding-your-objects" class="headerlink" title="holding your objects"></a>holding your objects</h3></li>
</ul>
<ol>
<li>generics and type-safe containers：和c++类似，java的容器可以使用基类的指针存储派生类。<code>List&lt;Base&gt; b = new ArrayList&lt;Base&gt; (); b.add(new Derived());</code>。</li>
</ol>
<ul>
<li>把<code>ArrayList</code>的implementation upcast成为<code>List interface</code>的原因是：可以随时改变实现，比如使用<code>List&lt;Base&gt; b = new LinkedList&lt;Base&gt;();</code>。</li>
<li>但是这种<code>upcast</code>也有不便的地方——如果要使用<code>ArrayList</code>中有而<code>List</code>中没有的方法，则不应该<code>upcast</code>。</li>
</ul>
<ol start="2">
<li>adding groups of elements: <code>Arrays.asList()</code>方法接受<code>变长参数</code>返回一个list，比如<code>Collection&lt;Integer&gt; coll = new ArrayList&lt;Integer&gt;(Arrays.asList(1, 2, 3));</code>。同时<code>Collections.addAll()</code>方法接受传入一个list，和一个<code>变长参数</code>，向list中添加multi数据，类似于<code>List&lt;Integer&gt; coll = new ArrayList&lt;Integer&gt;(); Collections.addAll(coll, 1, 2);</code>。</li>
<li>printing container: 可以直接调用<code>out.println(Containerxx)</code>，print内部使用容器自身的<code>toString()</code>方法打印容器内持有的元素。针对<code>HashSet</code>它的<code>storage order</code>和插入顺序无关，效率最高（因为是hash)；针对<code>TreeSet</code>它的<code>storage order</code>是<code>ascending comparison order</code>；而针对<code>LinkedHashSet</code>它的<code>storage order</code>和<code>insert order</code>相同。</li>
</ol>
<ul>
<li><code>HashMap</code>和<code>TreeMap</code>和<code>LinkedHashMap</code>和上述类似。</li>
</ul>
<ol start="4">
<li>List：主要<code>ArrayList</code>和<code>LinkedList</code>。</li>
</ol>
<ul>
<li>⚠️<code>add(E e)</code>方法和⚠️<code>add(int index, E element)</code>方法⚠️<code>set(int index, E element)</code>方法；add在指定位置插入element，set替换指定位置的element。<br>⚠️<code>contains(Object o)</code>方法⚠️<code>remove(Object o)</code>方法⚠️<code>indexOf(Object o)</code>方法和<code>remove(int index)</code>方法；删除可以指定index或者元素自身删除。<br>⚠️<code>subList(int fromIndex, int toIndex)</code>方法⚠️<code>retainAll(Collection&lt;?&gt; c)</code>方法；其中retainAll表示list只保留指定collection中的元素，其它全部删除。<br>⚠️<code>toArray(T[] a)</code>将list转换成为array。</li>
<li>ArrayList的<code>random access</code>比较快，<code>LinkedList</code>的<code>insert/remove element in middle</code>比较快。</li>
</ul>
<ol start="5">
<li>Iterator: 和C++类似，迭代器可以让代码和<code>实际的容器类型</code>解耦。它有<code>hasNext()</code>和<code>next()</code>方法；所有的容器都有<code>iterator()</code>方法；注意它的<code>remove()</code>方法移除的是<code>next</code>生产的element，所以调用<code>remove之前要调用next</code>。</li>
</ol>
<ul>
<li><code>ListIterator</code>相比有<code>bidirection</code>因此它有<code>hasPrevious()</code>和<code>previous()</code>方法；同时List容器的<code>listIterator(int index)</code>支持指定位置的迭代器，使用迭代器<code>set(E e)</code>可以通过迭代器修改element。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Pet p = it.next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  ArrayList&lt;Pet&gt; pets = Pets.arrayList(<span class="number">8</span>);</span><br><span class="line">  TreeSet&lt;Pet&gt; petsTS  = <span class="keyword">new</span> TreeSet&lt;Pet&gt;(pets);</span><br><span class="line">  display(pets.iterator());</span><br><span class="line">  display(petsTS.iterator());</span><br><span class="line">  Iterator&lt;Pet&gt; it = pets.iterator();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">3</span>; i++)&#123;</span><br><span class="line">    it.next();</span><br><span class="line">    it.remove();</span><br><span class="line">  &#125;</span><br><span class="line">  ListIterator&lt;Pet&gt; lit = pets.listIterator(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(lit.hasPrevious())&#123;</span><br><span class="line">    Pet pe = lit.previous();</span><br><span class="line">    System.out.print(pe.id() + <span class="string">&quot;:&quot;</span> + pe + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ListIterator&lt;Pet&gt; lt = pets.listIterator(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span>(lt.hasNext())&#123;</span><br><span class="line">    lt.next();</span><br><span class="line">    lt.set(Pets.randomPet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="6">
<li>LinkedList：和c++的容器适配器（queue/stack）类似，<code>LinkedList</code>可以用来作为<code>Queue</code>的实现。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/13/thinking-in-java/" data-id="ckdsoysin00029y0c45ij6z6h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/13/hello-world/" class="article-date">
  <time datetime="2020-08-13T08:31:07.898Z" itemprop="datePublished">2020-08-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/13/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/13/hello-world/" data-id="ckdsoysi700009y0c5ppk1zah" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/13/c-primer/">c++primer</a>
          </li>
        
          <li>
            <a href="/2020/08/13/thinking-in-java/">thinking-in-java</a>
          </li>
        
          <li>
            <a href="/2020/08/13/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>