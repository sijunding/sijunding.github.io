<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>thinking-in-java | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Thinking in javaintroduction access control: package access默认是private 使用基类的指针&#x2F;引用指向派生类的对象，在java中叫做upcasting，up原因是在uml中base class都是在最上面的。 rooted hierarchy: 对于java而言Object是所有对象的基类，这对于garbage collector很有用">
<meta property="og:type" content="article">
<meta property="og:title" content="thinking-in-java">
<meta property="og:url" content="http://yoursite.com/2020/08/13/thinking-in-java/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Thinking in javaintroduction access control: package access默认是private 使用基类的指针&#x2F;引用指向派生类的对象，在java中叫做upcasting，up原因是在uml中base class都是在最上面的。 rooted hierarchy: 对于java而言Object是所有对象的基类，这对于garbage collector很有用">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-08-13T10:44:40.000Z">
<meta property="article:modified_time" content="2020-08-13T10:44:51.079Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-thinking-in-java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/13/thinking-in-java/" class="article-date">
  <time datetime="2020-08-13T10:44:40.000Z" itemprop="datePublished">2020-08-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      thinking-in-java
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Thinking-in-java"><a href="#Thinking-in-java" class="headerlink" title="Thinking in java"></a>Thinking in java</h2><h3 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h3><ol>
<li>access control: <code>package access</code>默认是<code>private</code></li>
<li>使用基类的指针/引用指向派生类的对象，在java中叫做<code>upcasting</code>，up原因是在uml中base class都是在最上面的。</li>
<li>rooted hierarchy: 对于java而言<code>Object</code>是所有对象的基类，这对于<code>garbage collector</code>很有用。</li>
<li>applet: An applet is a mini-program that will run only under a Web browser. applet是java丰富了客户端编程技术，一般browser是需要写js文件的。<h3 id="everything-is-a-object"><a href="#everything-is-a-object" class="headerlink" title="everything is a object"></a>everything is a object</h3></li>
<li><code>String s; s = new String(&quot;asdf&quot;);</code>其中<code>s</code>是一个<code>reference</code>，就是c++中的指针，放在<code>stack</code>上；真实对象放在<code>heap</code>堆里。</li>
<li><code>primitive type</code>：基本类型比如<code>boolean/char/short/int/long/double</code>等可以直接在<code>stack</code>上创建(<code>char c = &#39;x&#39;</code>)这样效率更高；而且和c++不同基本类型占用的字节数<code>固定</code>和机器无关。</li>
</ol>
<ul>
<li><code>Character ch = new Character(&#39;x&#39;);</code>基本类型也具备对应的<code>wrapper type</code>。</li>
</ul>
<ol start="3">
<li><code>Arrays in java</code>：和c++不同的是，java保证<code>array</code>默认<code>initialize为null</code></li>
</ol>
<ul>
<li>create an array of object，等价与creat <code>an array of references and each reference is automatically initialized to null</code>。</li>
</ul>
<ol start="4">
<li><code>default values for primitive class memebers</code>：针对类中的基础类型，和c++不同的是，java保证初始化。</li>
</ol>
<ul>
<li>如果是基础类型则保证为0，如果是类类型则保证为null。</li>
</ul>
<ol start="5">
<li><code>name visibility</code>：和c++需要使用<code>namespace</code>来解决重定义问题不一样，java使用<code>net.mindview.Class</code>的<code>domain name</code>来解决名字冲突问题。</li>
</ol>
<ul>
<li><code>import java.util.ArrayList;</code>java使用<code>import</code>关键词来指定类的路径；注意<code>java.lang</code>包是隐式被import到所有的java文件中的，所以<code>String</code>等类就不用显式import。</li>
</ul>
<ol start="6">
<li><code>compiling and running</code>：编译通过<code>javac xx.java</code>产生java的字节码<code>xx.class</code>；运行通过<code>java xx</code>即可。了解下jdk和jre的区别。<h3 id="operators"><a href="#operators" class="headerlink" title="operators"></a>operators</h3></li>
<li><code>==</code>和<code>equals()</code>：<code>object</code>类中<code>equals</code>的默认实现就是比较<code>this</code>指针，派生的<code>Integer/String</code>类的<code>equals</code>则比较内容；<code>==</code>默认肯定是比较<code>this</code>指针，因此如果想判断<code>String</code>的内容是否相等用equals。</li>
<li><code>&gt;&gt;</code>和<code>&gt;&gt;&gt;</code>：针对<code>&gt;&gt;</code>和c++一样，如果是positive，高位就填充0，如果是negative，高位就填充1；和<code>&gt;&gt;&gt;</code>则不管统一填充0。</li>
<li><code>&quot;&quot;+a</code>是一个比较常见的int转string方式（类似于Integer.toString()).</li>
<li>关于<code>label</code>标签只有一种用法如下，<code>continue label1</code>将会跳到外层循环，并且继续从外层循环开始执行；而<code>break label1</code>也会跳到外层循环，但直接终止不会<code>reenter</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> label1:</span><br><span class="line">    outer-iteration &#123;</span><br><span class="line">      inner-iteration &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// (1)</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// (2)</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">continue</span> label1; <span class="comment">// (3)</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">break</span> label1; <span class="comment">// (4)</span></span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="initialization-amp-cleanup"><a href="#initialization-amp-cleanup" class="headerlink" title="initialization &amp; cleanup"></a>initialization &amp; cleanup</h3></li>
<li><code>calling constructors from constructors</code>：可以使用<code>this</code>在constructor中调用其它constructor，不过必须是<code>第一行</code>；类似于<code>Base(int a, int b)&#123;this(a);...&#125;</code>。</li>
<li><code>finalize</code>：是类的一个方法，它的目的通常是做一些<code>gc</code>无法处理的<code>cleanup</code>工作。</li>
</ol>
<ul>
<li>gc只能释放<code>new</code>占用的内存；它会首先调用类的<code>finalize()</code>方法，然后gc；</li>
<li>比如说在java中调用了<code>c++</code>的<code>malloc</code>，那么就需要在<code>finalize</code>中调用<code>free</code>释放，这是finalize存在的部分原因。</li>
<li>finalize的另外一个使用场景：在其中<code>close file</code>关闭已经打开的文件句柄，防止句柄泄露。</li>
<li>jvm只会在<code>必要</code>的时候调用gc以释放内存；finalize方法<code>不能主动调用</code>；因此如果一定要个类似于c++的destructor，就显示在java中定义这个方法，再显示调用吧。</li>
</ul>
<ol start="3">
<li><code>order of initilization</code>：和c++不同，java可以在定义class时，在其中可以直接给<code>member variable</code>写初始化语句，即使初始化语句写在<code>constructor</code>后面，也是先执行自身的<code>init</code>然后调用<code>constructor</code>。</li>
</ol>
<ul>
<li>当某个类第一次被调用，<code>xx.class</code>需要被load，就在此时该类的<code>static</code>成员被有且仅初始化一次；因此<code>static</code>成员变量的初始化时机最早。</li>
<li>java允许static成员直接在定义时初始化；同时java还支持<code>static initialization和instance initialization</code>这种语法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a = <span class="number">10</span>; <span class="comment">// static initialization</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">20</span>; <span class="comment">//instance initialization</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>array init: <code>int []a = new int[2];</code>默认初始化元素为0；等价于<code>Integer []a = new Integer[2]; a[x] = 0;</code>，因为<code>a[x]</code>如果不去初始化，则其中的引用默认为null；也可以直接初始化<code>Integer []a = new Integer[2]&#123;0, 0&#125;</code>。</li>
<li><code>toString</code>方法：基类Object默认是打印<code>ClsName@Addr</code>。</li>
<li><code>variable argument list</code>：语法为<code>void f(Object... args)</code>类似于c++的模版参数包，可以传递变参。</li>
<li>enum：enum的语法类似于c++的<code>enum class</code>，<code>enum A&#123;Red, Green, Blue&#125; A x = A.Red;</code>，它还有<code>ordinal()</code>方法用来获取从0开始的排号。<h3 id="access-control"><a href="#access-control" class="headerlink" title="access control"></a>access control</h3></li>
<li>package the library unit: 对于java来说，每一个源文件叫做<code>compilation unit</code>，在这个源文件中有且仅有一个<code>同名的public class</code>；如果定义其它class，则不能为<code>public</code>，该class会被package隐藏，<code>不会暴露</code>。</li>
<li>code organization: 源文件.java–&gt; 编译成.class–&gt; packaged and compressed into <code>jar file</code>—&gt; jvm负责装载、解释；</li>
</ol>
<ul>
<li>如果要开发第三方库，则开发者需要使用<code>package</code>，使用者使用<code>import</code>；并且使用者需要在<code>PATH</code>中添加路径；针对<code>jar</code>包需要在PATH中写入<code>全路径</code>(如C:\xx\graph.jar)</li>
<li>注意<code>import</code>进来的两个包如果有相同的class名，造成了<code>collision</code>，则在使用时<code>使用全名</code>即可。</li>
<li>如果没有写<code>package...</code>则会把<code>当前文件</code>当作<code>default package for current directory</code>。</li>
<li><code>import static java.lang.System.*;</code> import static可以导入所有的static方法和对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: access/mypackage/MyClass.java</span></span><br><span class="line"><span class="keyword">package</span> access.mypackage;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//: access/ImportedMyClass.java</span></span><br><span class="line"><span class="keyword">import</span> access.mypackage.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportedMyClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyClass m = <span class="keyword">new</span> MyClass();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>package access：对于java而言如果不加任何的<code>access specifier</code>则使用的就是<code>package access</code>权限，即针对<code>相同package内</code>的其它class它是<code>public</code>可见的；针对<code>不在同一个package</code>的其它class它是<code>private</code>不可见的。</li>
</ol>
<ul>
<li>对于class，只能有<code>public</code>或者<code>package access</code>。（除了内部类，内部类可以是private或者protected的)</li>
</ul>
<ol start="4">
<li>protected ：如果某个方法使用<code>protected</code>关键字，那么针对<code>不在同一个package</code>的其它<code>派生类</code>依然是可见的。</li>
</ol>
<ul>
<li>protected如其最基本的含义，对于<code>使用者</code>是不可见的，但是对于<code>派生类的定义</code>是可见的。</li>
<li>java的protected另外一层含义是<code>package access</code>即针对<strong>同包的其它文件可见</strong>！从原文解释为——this is <code>private as far as the class user</code>, but available to anyone who inherits from this class or <code>anyone else in the same package</code>。</li>
<li>记住java的<code>package</code>的概念是：同包内的所有文件来自于<code>同一个designer</code>；这有助于理解权限。</li>
</ul>
<h3 id="reusing-classes"><a href="#reusing-classes" class="headerlink" title="reusing classes"></a>reusing classes</h3><ol>
<li>inheritance syntax: 基本语法为<code>class Derived extends Base</code>通过关键词<code>extends</code>实现，和c++需要使用<code>virtual</code>关键词开启多态不同，java默认就开启多态。（除了static和final方法之外，所有方法默认多态）。</li>
</ol>
<ul>
<li><code>public static void main(String[] args)</code>是java的程序入口。</li>
<li>派生类调用基类方法<code>super.fun()</code>使用<code>super</code>关键字。</li>
</ul>
<ol start="2">
<li>initialize the base class: 在派生类的构造函数写上<code>super(xx)</code>即可先执行基类的构造函数；如果是<code>default constructor</code>（即无参数），java语言会默认调用基类默认构造函数。</li>
<li>finally：<code>try &#123;&#125;finally&#123;&#125;</code>子句，<code>finally always executed, no matter how the try block happen</code>，针对<code>非内存清理</code>的cleanup(gc只管内存清理)，可以在finally中做；比如某些业务逻辑。</li>
</ol>
<ul>
<li>类似于c++的destructor，不过destructor不用显示调用；相同点在于<code>逆序</code>调用即从derived开始最后到base。</li>
</ul>
<ol start="4">
<li>final data：<code>final</code>关键字作用在<code>primitive</code>基本类型上就是c++的constant的意思，表示是常量；作用在<code>object reference</code>上就相当于c++的<code>const 指针</code>——即不能在指向其它object，但是object自身可以modified。</li>
</ol>
<ul>
<li>一般情况下针对<code>primitive</code>会写成<code>public static final VALUE_A = 10</code>即<code>static final</code>一起用，static表示有且仅有一份内存，final表示constant；当然不是说一定要连在一起用。</li>
<li><code>final Base b = Base(1); b.x = 10;</code>针对类添加final只是说<code>reference</code>加了final，修改它的object还是可以的；但是<code>b = Base(2)</code>是错误的；</li>
<li>相同的原因<code>final int[] a=&#123;1, 2&#125;; a[0]++;</code>是正确的，final遇到数组也是加在所谓的<code>reference</code>上。</li>
<li>和c++的const不同的是，可以在类中声明final成员，然后在构造函数中再初始化final成员——这叫做<code>blank final</code></li>
</ul>
<ol start="5">
<li>final methods：第一种用法是<code>prevent inheriting class changing method meaning</code>；第二种用法相当于c++的<code>inline</code>内联函数，不过现在虚拟机一般会自动优化。</li>
</ol>
<ul>
<li>针对<code>private methods</code>默认就带有<code>final</code>属性因为它不能被继承；但是如果基类是<code>public final method</code>派生类默认是拥有的，只是不能<code>change</code>。</li>
</ul>
<ol start="6">
<li>final class：就是这个类<code>不能被继承</code>。<h3 id="polymorphism"><a href="#polymorphism" class="headerlink" title="polymorphism"></a>polymorphism</h3></li>
<li>多态：<code>Shape s = new Circle(); s.draw();</code>多态常见的用法和c++类似，使用基类的指针指向派生类的对象。一种良好的设计模式如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span></span>&#123;</span><br><span class="line">    i.play();<span class="comment">//接口可以保持不变</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>如前所述：针对<code>static/final</code>方法和同名的<code>field</code>，<code>Base b = new Derived(); b.sameF; b.staticFunc();</code>都不会触发多态，原因是在<code>编译时就决定</code>，而非运行时。</li>
<li>polymorphic method inside constructors：和c++一样，不要在构造函数中调用多态函数。</li>
<li>RTTI：就是downcast，类似于<code>Base b = new Derived(); ((Derived)b).derivedFun();</code>这种在运行时检查类型的方式就是<code>runtime type identification</code>；类似于c++的dynamic_cast。<h3 id="interfaces"><a href="#interfaces" class="headerlink" title="interfaces"></a>interfaces</h3></li>
</ul>
<ol>
<li>abstract class：和c++的<code>pure virtual function</code>类似，使用<code>abstract void f();</code>这种<code>abstract</code>关键字的无body函数，就是<code>抽象类</code>。</li>
</ol>
<ul>
<li>也可以使用<code>abstract class A&#123;&#125;</code>关键字直接修饰类得到<code>抽象类</code>。</li>
</ul>
<ol start="2">
<li>interface：是一个完全的接口，里面只能包含<code>方法声明</code>和<code>字段</code>；方法默认是<code>public</code>的，字段默认是<code>public static final</code>的。</li>
</ol>
<ul>
<li>使用<code>implements</code>关键字实现这个interface；除此之外interface和class无异（包含<code>多态</code>等特性）；接口最大的功用就是decoupling，比类更加解耦。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Compile-time constant:</span></span><br><span class="line">  <span class="keyword">int</span> VALUE = <span class="number">5</span>; <span class="comment">// static &amp; final</span></span><br><span class="line">  <span class="comment">// Cannot have method definitions:</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span></span>; <span class="comment">// Automatically public</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">implements</span> <span class="title">Instrument</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>multiple inheritance：和c++可能会出现<code>菱形继承</code>不同，java只允许<code>extends</code>一个基类，但是允许<code>implements</code>无限个interface；同时多态的特性允许派生类<code>upcast</code>成为任意一个interface或者基类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFight</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">CanSwim</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ActionCharacter</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">ActionCharacter</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">CanFight</span>, <span class="title">CanSwim</span>, <span class="title">CanFly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>entending an interface with inheritance：和类相似，interface也可以通过<code>extend</code>派生出新的接口。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DangerousMonster</span> <span class="keyword">extends</span> <span class="title">Monster</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>adapting to an interface：把接口当作<code>函数参数</code>将非常有利于适配该函数。如下所示任何实现了<code>Readable</code>接口的自定义类都可以被<code>Scanner</code>使用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Readable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(java.nio.CharBuffer cb)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scanner</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Scanner</span><span class="params">(Readable source)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>factories：介绍工厂类的最常见用法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;</span><br><span class="line">  <span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;<span class="comment">//工厂的interface用来返回要生产的Object</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factories</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory fact)</span></span>&#123;<span class="comment">//真实消费的方法传入一个工厂的interface</span></span><br><span class="line">    Service s = fact.getService();<span class="comment">//工厂类生产Object</span></span><br><span class="line">    s.fun();<span class="comment">//用生产出来的Object进行业务</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    serviceConsumer(<span class="keyword">new</span> ImplementationFactoryA());</span><br><span class="line">    serviceConsumer(Implementation1.factory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImplementationServiceA</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImplementationFactoryA</span> <span class="keyword">implements</span> <span class="title">ServiceFactory</span></span>&#123;&#125; <span class="comment">//实际的实现，可以是A/B/C</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Implementation1</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//构造函数使用private</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory factory = <span class="keyword">new</span> ServiceFactory()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Implementation1();&#125;</span><br><span class="line">  &#125;;<span class="comment">//使用匿名内部类创建factory对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Inner-Classes"><a href="#Inner-Classes" class="headerlink" title="Inner Classes"></a>Inner Classes</h3></li>
<li>the link to the outer class：针对<code>non-static</code>的内部类，它默认会持有<code>外部类</code>的引用，所以能够在内部类中<code>能直接访问外部类的所有成员</code>—— <code>inner classes have access rights to all the elements in the enclosing class</code>.</li>
</ol>
<ul>
<li>外部类的<code>non-static</code>方法访问内部类：<code>直接使用InnerClass名</code>即可；外部类的<code>static</code>方法访问内部类：<code>使用OuterClass.InnerClass</code>。</li>
<li>内部类访问外部类的变量：<code>直接使用外部类的field名</code>；访问外部类的this指针：<code>使用OuterClass.this</code>。</li>
<li>创建<code>内部类对象</code>：需要<code>首先创建外部类对象</code>，语法为<code>OuterClass out = new OuterClass(); OuterClass.InnerClass inner = out.new InnerClass();</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">DotThis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;DotThis.f()&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> DotThis <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            out.println(a);</span><br><span class="line">            <span class="keyword">return</span> DotThis.<span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// A plain &quot;this&quot; would be Inner’s &quot;this&quot;</span></span><br><span class="line">        &#125; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Inner(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotThis dt = <span class="keyword">new</span> DotThis();</span><br><span class="line">        DotThis.Inner dti = dt.inner();</span><br><span class="line">        dti.outer().f();</span><br><span class="line">        DotThis.Inner dti2 = dt.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>inner classes and upcasting：内部类的一个通用做法是，使用<code>private 内部类 implements 接口</code>来实现具体细节，使用者<code>使用的是接口，因而完全不清楚实现细节</code>，如下所示。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parcel4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">implements</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PContents();</span><br><span class="line">    &#125; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParcel</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Parcel4 p = <span class="keyword">new</span> Parcel4();</span><br><span class="line">    Contents c = p.contents(); <span class="comment">//使用者不需要知道内部实现</span></span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li>inner classes in methods and scopes：内部类除了可以定义在外部类里，也可以定义在<code>method或者某个块</code>里面；比如定义在method里，<code>inner class cannot be accessed outside of the method</code>出了函数体无法<code>直接访问</code>内部类；因此常见做法和上述类似，通过<code>upcast</code>返回<code>内部类实现的接口</code>，接口对于user而言是可见的。</li>
<li>anonymous inner class：匿名内部类既可以<code>implements 接口</code>，又可以<code>extends 基类</code>。</li>
</ol>
<ul>
<li>如果在匿名内部类的定义里面使用了外部的变量，外部变量需要<code>使用final</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;<span class="comment">//等价于上面的PContents，这里使用了接口的default constructor</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;i = x;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//extends 基类的有参构造函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x)&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y1 = y;<span class="comment">//如果在匿名内部类的定义里面，使用了外部的变量需要使用final</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">super</span>.value()*<span class="number">2</span>;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li>factory method revisit：重新回顾工厂类的模式，添加上<code>匿名内部类</code>可以把实现细节给隐藏，具体可以参考前述。</li>
<li>nested class：和前述的<code>inner class</code>相比，<code>nested class</code>是专门指<code>static inner class</code>；其中最大的区别是——<code>static inner class不会默认持有外部类的this指针</code>。</li>
</ol>
<ul>
<li>外部类的<code>non-static/static</code>方法访问内部类：<code>直接使用InnerClass名</code>即可；</li>
<li><code>static inner class</code>访问外部类：只能访问<code>外部类的static field</code>；</li>
</ul>
<ol start="7">
<li>why inner classes：为什么不在<code>外部类impements内部类实现的接口</code>呢？原因是——有时外部类并没有implements对应的接口，而内部类就打破了这种限制。</li>
</ol>
<ul>
<li>java规定一个类只有一个base class，而内部类可以<code>extends class</code>，某种意义就突破了这层限制。</li>
</ul>
<ol start="8">
<li>closures &amp; callbacks：<code>closures</code>的定义是一个保存<code>环境信息</code>的<code>可执行对象</code>，<code>a callable object that retains information from the scope in which it was created</code>；java的内部类持有外部类的this指针因此是<code>clousure</code>。</li>
</ol>
<ul>
<li>c++使用<code>函数指针</code>实现callback功能；而java没有指针，java采用<code>closures</code>实现回调的功能。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Specify outer-class method, otherwise you’d get an infinite recursion:</span></span><br><span class="line">            Callee2.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125; &#125;</span><br><span class="line">    <span class="function">Incrementable <span class="title">getCallbackReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line">    Caller(Incrementable cbh) &#123; callbackReference = cbh; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123; callbackReference.increment(); &#125;</span><br><span class="line">&#125;</span><br><span class="line">Callee2 ce = <span class="keyword">new</span> Callee2();</span><br><span class="line">Caller c = Caller(ce.getCallbackReference());</span><br><span class="line"><span class="comment">//合适时机调用c.go();</span></span><br></pre></td></tr></table></figure>
<h3 id="holding-your-objects"><a href="#holding-your-objects" class="headerlink" title="holding your objects"></a>holding your objects</h3></li>
</ul>
<ol>
<li>generics and type-safe containers：和c++类似，java的容器可以使用基类的指针存储派生类。<code>List&lt;Base&gt; b = new ArrayList&lt;Base&gt; (); b.add(new Derived());</code>。</li>
</ol>
<ul>
<li>把<code>ArrayList</code>的implementation upcast成为<code>List interface</code>的原因是：可以随时改变实现，比如使用<code>List&lt;Base&gt; b = new LinkedList&lt;Base&gt;();</code>。</li>
<li>但是这种<code>upcast</code>也有不便的地方——如果要使用<code>ArrayList</code>中有而<code>List</code>中没有的方法，则不应该<code>upcast</code>。</li>
</ul>
<ol start="2">
<li>adding groups of elements: <code>Arrays.asList()</code>方法接受<code>变长参数</code>返回一个list，比如<code>Collection&lt;Integer&gt; coll = new ArrayList&lt;Integer&gt;(Arrays.asList(1, 2, 3));</code>。同时<code>Collections.addAll()</code>方法接受传入一个list，和一个<code>变长参数</code>，向list中添加multi数据，类似于<code>List&lt;Integer&gt; coll = new ArrayList&lt;Integer&gt;(); Collections.addAll(coll, 1, 2);</code>。</li>
<li>printing container: 可以直接调用<code>out.println(Containerxx)</code>，print内部使用容器自身的<code>toString()</code>方法打印容器内持有的元素。针对<code>HashSet</code>它的<code>storage order</code>和插入顺序无关，效率最高（因为是hash)；针对<code>TreeSet</code>它的<code>storage order</code>是<code>ascending comparison order</code>；而针对<code>LinkedHashSet</code>它的<code>storage order</code>和<code>insert order</code>相同。</li>
</ol>
<ul>
<li><code>HashMap</code>和<code>TreeMap</code>和<code>LinkedHashMap</code>和上述类似。</li>
</ul>
<ol start="4">
<li>List：主要<code>ArrayList</code>和<code>LinkedList</code>。</li>
</ol>
<ul>
<li>⚠️<code>add(E e)</code>方法和⚠️<code>add(int index, E element)</code>方法⚠️<code>set(int index, E element)</code>方法；add在指定位置插入element，set替换指定位置的element。<br>⚠️<code>contains(Object o)</code>方法⚠️<code>remove(Object o)</code>方法⚠️<code>indexOf(Object o)</code>方法和<code>remove(int index)</code>方法；删除可以指定index或者元素自身删除。<br>⚠️<code>subList(int fromIndex, int toIndex)</code>方法⚠️<code>retainAll(Collection&lt;?&gt; c)</code>方法；其中retainAll表示list只保留指定collection中的元素，其它全部删除。<br>⚠️<code>toArray(T[] a)</code>将list转换成为array。</li>
<li>ArrayList的<code>random access</code>比较快，<code>LinkedList</code>的<code>insert/remove element in middle</code>比较快。</li>
</ul>
<ol start="5">
<li>Iterator: 和C++类似，迭代器可以让代码和<code>实际的容器类型</code>解耦。它有<code>hasNext()</code>和<code>next()</code>方法；所有的容器都有<code>iterator()</code>方法；注意它的<code>remove()</code>方法移除的是<code>next</code>生产的element，所以调用<code>remove之前要调用next</code>。</li>
</ol>
<ul>
<li><code>ListIterator</code>相比有<code>bidirection</code>因此它有<code>hasPrevious()</code>和<code>previous()</code>方法；同时List容器的<code>listIterator(int index)</code>支持指定位置的迭代器，使用迭代器<code>set(E e)</code>可以通过迭代器修改element。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Pet p = it.next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  ArrayList&lt;Pet&gt; pets = Pets.arrayList(<span class="number">8</span>);</span><br><span class="line">  TreeSet&lt;Pet&gt; petsTS  = <span class="keyword">new</span> TreeSet&lt;Pet&gt;(pets);</span><br><span class="line">  display(pets.iterator());</span><br><span class="line">  display(petsTS.iterator());</span><br><span class="line">  Iterator&lt;Pet&gt; it = pets.iterator();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">3</span>; i++)&#123;</span><br><span class="line">    it.next();</span><br><span class="line">    it.remove();</span><br><span class="line">  &#125;</span><br><span class="line">  ListIterator&lt;Pet&gt; lit = pets.listIterator(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(lit.hasPrevious())&#123;</span><br><span class="line">    Pet pe = lit.previous();</span><br><span class="line">    System.out.print(pe.id() + <span class="string">&quot;:&quot;</span> + pe + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ListIterator&lt;Pet&gt; lt = pets.listIterator(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span>(lt.hasNext())&#123;</span><br><span class="line">    lt.next();</span><br><span class="line">    lt.set(Pets.randomPet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="6">
<li>LinkedList：和c++的容器适配器（queue/stack）类似，<code>LinkedList</code>可以用来作为<code>Queue</code>的实现。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/13/thinking-in-java/" data-id="ckdsoen8g0000an0cazcv28ee" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/08/13/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/13/thinking-in-java/">thinking-in-java</a>
          </li>
        
          <li>
            <a href="/2020/08/13/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>